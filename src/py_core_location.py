# generated by PyFileGenerator
# only intended for venv usage while writing code
# do not try add this file to a real app

from typing import Callable, Protocol, Optional
import datetime


class PyLocationManager:
	@staticmethod
	def shared() -> "PyLocationManager":
		pass

	def add_callback(self, callback: object):
		pass

	def remove_callback(self, callback: object):
		pass

	@staticmethod
	def locationServicesEnabled() -> bool:
		pass

	@staticmethod
	def headingAvailable() -> bool:
		pass

	@staticmethod
	def significantLocationChangeMonitoringAvailable() -> bool:
		pass

	@property
	def authorizationStatus(self) -> int:
		pass

	@property
	def activityType(self) -> int:
		pass

	@activityType.setter
	def activityType(self, value: int):
		pass

	@property
	def distanceFilter(self) -> float:
		pass

	@distanceFilter.setter
	def distanceFilter(self, value: float):
		pass

	@property
	def desiredAccuracy(self) -> float:
		pass

	@desiredAccuracy.setter
	def desiredAccuracy(self, value: float):
		pass

	@property
	def pausesLocationUpdatesAutomatically(self) -> bool:
		pass

	@pausesLocationUpdatesAutomatically.setter
	def pausesLocationUpdatesAutomatically(self, value: bool):
		pass

	@property
	def allowsBackgroundLocationUpdates(self) -> bool:
		pass

	@allowsBackgroundLocationUpdates.setter
	def allowsBackgroundLocationUpdates(self, value: bool):
		pass

	@property
	def showsBackgroundLocationIndicator(self) -> bool:
		pass

	@showsBackgroundLocationIndicator.setter
	def showsBackgroundLocationIndicator(self, value: bool):
		pass

	@property
	def location(self) -> Optional["CLLocation"]:
		pass

	@property
	def headingFilter(self) -> float:
		pass

	@headingFilter.setter
	def headingFilter(self, value: float):
		pass

	@property
	def headingOrientation(self) -> int:
		pass

	@headingOrientation.setter
	def headingOrientation(self, value: int):
		pass

	@property
	def heading(self) -> Optional["CLHeading"]:
		pass

	@property
	def maximumRegionMonitoringDistance(self) -> float:
		pass

	@property
	def monitoredRegions(self) -> set["CLRegion"]:
		pass

	@property
	def rangedBeaconConstraints(self) -> set["CLBeaconIdentityConstraint"]:
		pass

	def requestWhenInUseAuthorization(self):
		pass

	def requestAlwaysAuthorization(self):
		pass

	def requestTemporaryFullAccuracyAuthorization(self, purposeKey: str, completion: object):
		pass

	def startUpdatingLocation(self):
		pass

	def stopUpdatingLocation(self):
		pass

	def requestLocation(self):
		pass

	def startUpdatingHeading(self):
		pass

	def stopUpdatingHeading(self):
		pass

	def dismissHeadingCalibrationDisplay(self):
		pass

	def startMonitoringSignificantLocationChanges(self):
		pass

	def stopMonitoringSignificantLocationChanges(self):
		pass

	def startMonitoringLocationPushes(self, completion: object):
		pass

	def stopMonitoringLocationPushes(self):
		pass

	def stopMonitoring(self, region: "CLRegion"):
		pass

	def startMonitoring(self, region: "CLRegion"):
		pass

	def requestState(self, region: "CLRegion"):
		pass

	def startRangingBeacons(self, constraint: "CLBeaconIdentityConstraint"):
		pass

	def stopRangingBeacons(self, constraint: "CLBeaconIdentityConstraint"):
		pass
	class Callbacks:
		def didChangeAuthorization(self, manager: "PyLocationManager"):
			pass

		def didPauseLocationUpdates(self, manager: "PyLocationManager"):
			pass

		def didResumeLocationUpdates(self, manager: "PyLocationManager"):
			pass

		def shouldDisplayHeadingCalibration(self, manager: "PyLocationManager") -> bool:
			pass

		def didVisit(self, manager: "PyLocationManager", visit: "CLVisit"):
			pass

		def didExitRegion(self, manager: "PyLocationManager", region: "CLRegion"):
			pass

		def didEnterRegion(self, manager: "PyLocationManager", region: "CLRegion"):
			pass

		def didUpdateHeading(self, manager: "PyLocationManager", newHeading: "CLHeading"):
			pass

		def didUpdateLocations(self, manager: "PyLocationManager", locations: list["CLLocation"]):
			pass

		def didFailWithError(self, manager: "PyLocationManager", error: str):
			pass

		def didRangeBeacons(self, manager: "PyLocationManager", beacons: list["CLBeacon"], beaconConstraint: "CLBeaconIdentityConstraint"):
			pass

		def didStartMonitoringFor(self, manager: "PyLocationManager", region: "CLRegion"):
			pass

		def didDetermineState(self, manager: "PyLocationManager", state: int, region: "CLRegion"):
			pass

		def didFailRangingFor(self, manager: "PyLocationManager", beaconConstraint: "CLBeaconIdentityConstraint", error: str):
			pass

		def didFinishDeferredUpdatesWithError(self, manager: "PyLocationManager", error: Optional[str]):
			pass

		def monitoringDidFailFor(self, manager: "PyLocationManager", region: Optional["CLRegion"], error: str):
			pass




class CLBeacon:
	@property
	def timestamp(self) -> datetime.datetime:
		pass

	@property
	def proximity(self) -> int:
		pass

	@property
	def accuracy(self) -> float:
		pass

	@property
	def rssi(self) -> int:
		pass

	@property
	def id(self) -> str:
		pass




class CLBeaconIdentityConstraint:
	@property
	def major(self) -> Optional[int]:
		pass

	@property
	def minor(self) -> Optional[int]:
		pass




class CLFloor:
	@property
	def level(self) -> int:
		pass




class CLHeading:
	@property
	def magneticHeading(self) -> float:
		pass

	@property
	def trueHeading(self) -> float:
		pass

	@property
	def headingAccuracy(self) -> float:
		pass

	@property
	def x(self) -> float:
		pass

	@property
	def y(self) -> float:
		pass

	@property
	def z(self) -> float:
		pass

	@property
	def timestamp(self) -> datetime.datetime:
		pass




class CLLocation:
	@property
	def coordinate(self) -> tuple[float, float]:
		pass

	@property
	def altitude(self) -> float:
		pass

	@property
	def horizontalAccuracy(self) -> float:
		pass

	@property
	def verticalAccuracy(self) -> float:
		pass

	@property
	def course(self) -> float:
		pass

	@property
	def speed(self) -> float:
		pass

	@property
	def speedAccuracy(self) -> float:
		pass

	@property
	def timestamp(self) -> datetime.datetime:
		pass

	@property
	def floor(self) -> Optional["CLFloor"]:
		pass

	def distance(self, location: "CLLocation") -> float:
		pass




class CLRegion:
	@property
	def identifier(self) -> str:
		pass

	@property
	def notifyOnEntry(self) -> bool:
		pass

	@notifyOnEntry.setter
	def notifyOnEntry(self, value: bool):
		pass

	@property
	def notifyOnExit(self) -> bool:
		pass

	@notifyOnExit.setter
	def notifyOnExit(self, value: bool):
		pass




class CLVisit:
	@property
	def arrivalDate(self) -> datetime.datetime:
		pass

	@property
	def departureDate(self) -> datetime.datetime:
		pass

	@property
	def coordinate(self) -> tuple[float, float]:
		pass

	@property
	def horizontalAccuracy(self) -> float:
		pass